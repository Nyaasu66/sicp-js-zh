### 1.2.4 取幂

考虑计算给定数字的指数的问题。我们想要一个函数，它以基数`b`和正整数指数`n`作为参数，并计算 b ^n 。一种方法是通过递归定义

```js
bn = b bn–1
b0 = 1
```

这很容易转化为函数

```js
function expt(b, n) {
    return n === 0
           ? 1
           : b * expt(b, n - 1);
}
```

这是一个线性递归过程，需要θ(n 步和θ(n 空间)。正如阶乘，我们可以很容易地制定一个等价的线性迭代:

```js
function expt(b, n) {
    return expt_iter(b, n, 1);
}
function expt_iter(b, counter, product) {
    return counter === 0
           ? product
           : expt_iter(b, counter - 1, b * product);
}
```

这个版本需要θ(n)步和θ(1)空间。

通过使用连续平方，我们可以用更少的步骤计算指数。例如，不是计算 b8 为

```js
b · (b · (b · (b · (b · (b · (b · b))))))
```

我们可以用三次乘法来计算:

```js
b2 = b · b
b4 = b2 · b2
b8 = b4 · b4
```

这种方法适用于指数为 2 的幂的情况。如果我们使用这个规则，我们也可以利用连续平方来计算指数

```js
bn = (bn/2)2  if n is even
bn = b · bn–1  if n is odd
```

我们可以将这种方法表达为一个函数:

```js
function fast_expt(b, n) {
    return n === 0
           ? 1
           : is_even(n)
           ? square(fast_expt(b, n / 2))
           : b * fast_expt(b, n - 1);
}
```

其中，测试整数是否为偶数的谓词是根据运算符`%`定义的，该运算符通过

```js
function is_even(n) {
    return n % 2 === 0;
}
```

由`fast_expt`进化的过程在空间和步骤数量上都与`n`成对数增长。要了解这一点，可以观察到使用`fast_expt`计算 b2nT30 只需要比计算 b^n多一次乘法运算。因此，我们可以计算的指数的大小随着我们被允许的每一次新乘法而加倍(大约)。因此，`n`的指数所需的乘法次数大约与`n`以 2 为底的对数一样快。这个过程有θ(logn)的增长。 [^(35)](#c1-fn-0035)

随着`n`变大，θ(对数`n`增长和θ(n)增长之间的差异变得显著。例如， n = 1000 的`fast_expt`只需要 14 次乘法。 [^(36)](#c1-fn-0036) 也可以利用连续平方的思想设计一种迭代算法，用对数步数计算指数(见练习 1.16)，尽管迭代算法通常不会像递归算法那样简单明了。 [^(37)](#c1-fn-0037)

##### 练习 1.16

像`fast_expt`一样，设计一个演化出迭代取幂过程的函数，该过程使用连续平方和对数步数。(提示:使用观察值(b^n^(/2))²=(b²)^n^(/2)，连同指数`n`和基数`b`，保留一个额外的状态变量`a`过程开始时`a`取 1，过程结束时`a`的值给出答案。一般来说，定义一个从一个状态到另一个状态保持不变的不变量的技术是一种考虑迭代算法设计的强大方法。)

##### 练习 1.17

本节中的取幂算法基于通过重复乘法来执行取幂。以类似的方式，可以通过重复加法来执行整数乘法。以下乘法函数(其中假设我们的语言只能加法，不能乘法)类似于`expt`函数:

```js
function times(a, b) {
    return b === 0
           ? 0
           : a + times(a, b - 1);
}
```

该算法采取了许多步骤，这些步骤在`b`中是线性的。现在假设我们除了加法之外，还包括函数`double`，它将一个整数加倍，以及函数`halve`，它将一个(偶数)整数除以 2。使用这些，设计一个类似于`fast_expt`的乘法函数，使用对数级。

##### 练习 1.18

利用练习 1.16 和 1.17 的结果，设计一个函数，产生一个迭代过程，用加法、加倍和减半的方式将两个整数相乘，并使用对数级数的步骤。 [^(38)](#c1-fn-0038)

##### 练习 1.19

有一个聪明的算法可以在对数级中计算斐波那契数。回忆 1.2.2 节`fib_iter`过程中状态变量`a`和`b`的变换:a+`b`和 b`a`。将这个转换称为 T ，观察到从 1 和 0 开始，反复应用 Tn 次`n`次，产生 Fib( n + 1)和 Fib( n )对。换句话说，斐波那契数列是通过应用 T^n、变换 T 的`n`次方而产生的，从对(1，0)开始。现在考虑 T 是一族变换 T [pq] 中 p = 0 和 q = 1 的特例，其中 T [pq] 根据 a←bq+【t5t】变换对(`a`， b )说明如果我们将这样的变换 T [pq] 应用两次，效果与使用相同形式的单个变换 T[p][′][q][′]相同，并且计算 p′和 q′这为我们提供了一种明确的方法来平方这些变换，因此我们可以使用连续平方来计算 T ^n ，就像在`fast_expt`函数中一样。将所有这些放在一起，完成下面的函数，它以对数级的步骤运行: [^(39)](#c1-fn-0039)

```js
function fib(n) {
    return fib_iter(1, 0, 0, 1, n);
}
function fib_iter(a, b, p, q, count) {
    return count === 0
           ? b
           : is_even(count)
           ? fib_iter(a,
                      b,
                      (??),          // compute p′
                      (??),          // compute q′
                      count / 2)
           : fib_iter(b * q + a * q + a * p,
                      b * p + a * q,
                      p,
                      q,
                      count - 1);
}
```
